## 概述
虚拟机把描述类的数据从CLass文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是Java虚拟机的类加载机制。

运行期加载和动态连接使得Java天生可以动态扩展。

## 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，生命周期包括：**加载**，**连接（验证，准备解析）**，**初始化**，**使用**，**卸载**

java虚拟机严格规定了有且只有5种情况必须立即对类进行“初始化”
- 遇到new，getstatic，setstatic或invokestatic这四条字节码指令时，如果类没有进行初始化，则需要先触发其初始化
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（)方法的那个类），虚拟机会先初始化这个主类
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则需要先触发其初始化

以上5种场景称为**对一个类进行主动引用**，除此之外，所有引用类的方式都不会触发初始化，称为**被动引用**，被动引用的场景有如下

- 通过子类引用父类的静态字段，不会导致子类被初始化
- 通过数组定义来引用类，不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

todo：引申([常量池深入](https://cloud.tencent.com/developer/article/1450501))

接口的加载过程只有当真正使用到父类的接口时（引用接口中定义的常量）才会被初始化
