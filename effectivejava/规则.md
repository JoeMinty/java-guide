# 创建和销毁对象

## 避免创建不必要的对象

## 消除过期的对象引用

## 避免使用终结方法和清除方法

## try-with-resources 优先于 try-finally

# 所有对象都通用的方法

## 覆盖equals时请遵守通用约定
- 类的每个实例本质上都是唯一的

- 类没有必要提供“逻辑相等”的测试功能

- 超类已经覆盖了equals方法，超类的行为对于这个类也是合适的

- 类是私有的，或者是包级别私有的，可以确定它的equals方法永远不会被调用

### equals方法实现类等价关系，其属性如下：
- 自反性

- 对称性

- 传递性

- 一致性

- 对于任何非null的引用值x，x.equals(null)必须返回false

### 实现高质量equals方法的诀窍
- 使用 == 操作符检查 “参数是否为这个对象的引用”

- 使用 instanceof 操作符检查 “参数是否为正确的类型”

- 把参数转换成正确的类型

- 对于该类中的每个“关键”（significant）域，检查参数中的域是否与该对象中对应的域相匹配

#### 额外告诫
- 覆盖equals时总要覆盖hashCode

- 不要企图让equals方法过于智能

- 不要将equals声明中的Object对象替换为其他的类型

## 覆盖equals时总要覆盖hashCode
Object规范：

- 在应用程序指定期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致

- 如果两个对象根据equals(Object)方法比较相等，那么调用这两个对象的hashCode方法都必须产生同样的整数结果

- 如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象的hashCode方法，则不一定要求hashCode方法产生不同的结果

一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”，这样可以提高散列表的性能

### 不要试图从散列码计算中排除掉一个对象的关键域来提高性能
这样可能导致散列函数把所有实例映射到极少数的散列码上，比如一个String散列函数最多智能使用16个字符，若长度少于16个字符则计算所有的字符，否则就从第一个开始，在整个字符串中间隔均匀的选取样本进行计算，对于URL这中层次状名称的大型集合，该散列函数正好表现出了这种病态行为

### 不要对hashCode方法的返回值作出具体的规定，因此客户端无法理所当然的依赖它，这样可以为修改提供灵活性

## 12.始终要覆盖toString
提供好的toString实现可以使类用起来更加舒适，使用了这个类的系统也更易于调试，在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息

## 13.谨慎地覆盖clone
Object规范：

创建和返回该对象的一个拷贝。

- x.clone() != x

- x.clone().getClass() == x.getClass()

- x.clone().equals(x), 并不是绝对的要求

## 14.考虑实现Comparable接口
```java
  public interface Comparable<T> {
    int compareTo(T t);
  }
```




