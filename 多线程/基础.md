# synchronized关键字

### synchronized关键字最主要的三种使用方式
- 修饰实例方法：
作用于当前对象实例上加锁，进入同步代码前要获取当前对象实例的锁

- 修饰静态方法：
作用于当前类加锁，会作用于类的所有对象实例

- 修饰代码块：
需要指定加锁对象，进入同步代码前需要获得给定对象的锁

### synchronized关键字的底层原理

`synchronized`的底层实现主要依靠 `Lock-Free` 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。

- **synchronized**修饰代码块

`synchronized`同步语句块的实现使用的是`monitorenter`和`monitorexit`指令，其中`monitorenter`指令指向同步代码块的开始位置，`monitorexit`指令则指明同步代码块的结束位置。

- **synchronized**修饰方法

`ACC_SYNCHRONIZED`标识，该标识指明了该方法是一个同步方法，JVM 通过该`ACC_SYNCHRONIZED`访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。


# volatile关键字

### volatile关键字作用
`volatile`关键字的主要作用就是**保证变量的可见性**和**防止指令重排序**

下面看一段单例模式的代码
```java

/** 双重校验锁实现对象单例（线程安全）*/
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        // 先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            // 类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}

// 单例模式目前另一种比较好的方法是通过内部类来实现
```
上面的代码`uniqueInstance`变量用`volatile`关键字修饰，`uniqueInstance = new Singleton();`这段代码分为三步执行：
+ 为`uniqueInstance`分配内存空间

+ 初始化`uniqueInstance`

+ 将`uniqueInstance`指向分配的内存地址

但由于`JVM`具有指令重排的特性，执行顺序有可能变成 1->3->2，使用`volatile`可以禁止`JVM`的指令重排，保证在多线程环境下也能正常运行。

### volatile关键字和synchronized关键字的对比
- 多线程访问`volatile`关键字不会发生阻塞，而`synchronized`关键字可能会发生阻塞

- `volatile`关键字保证数据的可见性，但不能保证数据的原子性，`synchronized`关键字两者都能保证

- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而`synchronized`关键字解决的是多个线程之间访问资源的同步性

- `volatile`关键字是线程同步的轻量级实现，`volatile`性能肯定比`synchronized`关键字要好。但是`volatile`关键字只能用于变量而`synchronized`关键字可以修饰方法以及代码块。`synchronized`关键字在JavaSE1.6之后进行了优化，实际开发中使用`synchronized`关键字的场景还是更多

### 总结
只有在状态真正独立于程序内其他内容时才能使用`volatile`


# ThreadLocal
### ThreadLocal主要作用
如果想实现每一个线程都有自己的专属本地变量，那么可以用`ThreadLocal`类，`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
