### 新建线程
### 终止线程
### 中断线程

```java
  public void Thread.interrupt()              // 中断线程
  public boolean Thread.isInterrupted()       // 判断是否被中断
  public static boolean Thread.interrupted()  // 判断是否被中断，并清除当前中断状态
```
`Thread.sleep()`方法会让当前线程休眠若干时间，会抛出`InterruptedException`中断异常

`Thread.sleep()`方法由于中断而抛出异常，此时，它会清除中断标记，如果不加处理，那么在下一次循环开始时，就无法捕获这个中断，故在异常处理中，再次设置中断标记位

### 等待（wait）和通知（notify）
`Object`类
```java
  public final void wait() throws InterruptedException
  
  public final native void nofity()
```
`Object.wait()`方法并不能随便调用，它必须包含在对应的`synchronized`语句中

`Object.wait()`方法和`Thread.sleep()`方法都可以让线程等待若干时间，`wait()`方法可以被唤醒，还会释放目标对象的锁，而`Thread.sleep()`方法不会释放任何资源


### 挂起（suspend）和继续执行（resume）线程

不推荐使用，已经废弃。

`suspend()`方法在导致线程暂停的同时，并不会释放任何锁资源。

可以使用wait()和notify()方法来替换挂起和继续执行。

### 等待线程结束（join）和谦让（yeild）
`join()`方法的本质是让调用线程`wait()`

```java
  while(isAlive()) {
    wait(0);
  }
```


`Thread.yield()`
```java
  public static native void yield();
```
这是一个静态方法，一旦执行，它会使当前线程让出cpu。

### 守护进程（daemon）
垃圾回收线程，JIT线程

### 线程优先级
```java
  public final static int MIN_PRIORITY = 1;
  public final static int NORM_PRIORITY = 5;
  public final static int MAX_PRIORITY = 10;
```

### synchronized
限制的多个线程其实是串行执行的

## JDK并发包
### 重入锁
完全替代`synchronized`，重入锁使用`java.util.concurrent.locks.ReentrantLock`类来实现。
#### 1.中断响应
`synchronized`，如果一个线程在等待锁，那么结果只有两种情况，要么获得这把锁继续执行，要么保持等待。而使用可重入锁，线程可以被中断。
`lockInterruptibly()`可以对中断进行相应的锁申请动作，即在等待锁的过程中，可以响应中断。

#### 2.锁申请等待限时
```java
  public class TimeLock implements Runnable {

    public static ReentrantLock lock = new ReentrantLock();

    public void run() {
        try {
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                Thread.sleep(6000);
            } else {
                System.out.println("get lock failed");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if (lock.isHeldByCurrentThread())
                lock.unlock();
        }

    }

    public static void main(String[] args) {
        TimeLock tl = new TimeLock();
        Thread t1 = new Thread(tl);
        Thread t2 = new Thread(tl);
        t1.start();
        t2.start();
    }
}
```
#### 3.公平锁
公平锁的：不会出现饥饿现象，只要排队就会得到资源。用关键字`synchronized`进行锁控制，产生非公平锁。可重入锁允许构造公平锁，公平锁必然要求维护一个有序队列，实现成本高，性能低，默认都是非公平锁。
```java
  public ReentrantLock(boolean fair)
```

总结下：
根据系统的调度，一个线程会倾向于再次获取已经持有的锁，这种分配方式是高效的，但是无公平性。

可重入锁的实现包含三个要素
1.原子状态。原子状态使用cas操作来存储当前锁的状态，判断锁是否已经被别的线程持有；
2.等待队列。所有没有请求到锁的线程，都会进入等待队列
3.park()和unpark()，用来挂起和恢复线程，没有得到锁的线程将会被挂起。


`ReentrantLock`重要方法：

- lock()
  获得锁
- unlock()
  释放锁
- lockInterruptibly()
  获得锁，优先响应中断
- tryLock()
  尝试获得锁，如果成功，返回true，失败返回false
- tryLock(long time, TimeUnit unit)
  在给定时间内尝试获得锁
 





