http://www.importnew.com/29813.html

https://www.cnblogs.com/yulinfeng/p/7039979.html

# 线程池
### 什么是线程池
可以看做是一组线程的集合

### 为什么要用线程池
- **降低资源消耗**：通过重复利用已创建的线程降低线程创建和销毁造成的消耗

- **提高响应速度**：当任务到达时，任务可以不需要的等到线程创建就能立即执行

- **提高线程的可管理性**：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
	

### 继承关系

#### Executor
顶层的接口Executor仅仅体用了一个方法
```java
public interface Executor {

    /**
     * 在线程池中选择空闲的线程执行指定的命令
     */
    void execute(Runnable command);
}
```

#### ThreadPoolExecutor
```java
/**
 * corePoolSize：   核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务
 * maximumPoolSize：线程池所能维护的最大线程数
 * keepAliveTime：  超过corePoolSize线程，空闲线程的存活时间
 * unit：           keepAliveTime的时间单位
 * workQueue：      任务队列，用户缓存未执行的任务
 * threadFactory：  线程工厂
 * handler：        拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略来处理新任务，默认是AbortPolicy，直接抛出异常
 */
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
