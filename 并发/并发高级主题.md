## 显示锁
### Lock和ReentrantLock
`Lock`是接口，定义了一组抽象的加锁操作。与内置加锁机制不同的是，`Lock`提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显示的。

内置锁的局限性：
- 无法中断一个正在等待获取锁的线程
- 无法在请求获取一个锁时无限等待下去
- 无法实现非阻塞结构的加锁规则

```java
  Lock lock = new ReentrantLock();
  ...
  
  lock.lock();
  try {
    // 更新对象状态
    // 捕获异常，并在必要时恢复不变性条件
  } finally {
    lock.unlock();
  }
```

#### 轮询锁和定时锁
比起无条件的锁获取模式来说，可定时、可 轮询锁获取模式是通过`tryLock`方法实现的，它具备更完善的错误恢复机制。

#### 可中断的锁获取操作
`lockInterruptibly`方法能够在获得锁的同时保持对中断的响应
```java
  lock.lockInterruptibly();
  try {
    ...
  } finally {
    lock.unlock();
  }
```

### 性能考虑因素
竞争性能是可伸缩性的关键要素：如果有越多的资源被耗费在锁的管理和调度上，那么应用程序得到的资源就越少。

锁的实现方式越好，就需要越少的系统调用和上下文切换，并且在共享内存总线上的内存同步通信量也越少，而一些耗时的操作将占用应用程序的计算资源。

### 公平性
在公平的锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中；在非公平性的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。

公平锁不一定会带来性能上的优化，当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。

### synchronized 和 ReentrantLock 之间的选择
在一些内置锁无法满足需求的情况下，`ReentrantLock`可以作为一种高级工具，当需要一些高级功能时才应该使用`ReentrantLock`，这些功能包括：

**可定时的、可轮询的、可中断的锁获取操作，公平队列，以及非块结构的锁**，否则，应该优先选用`synchronized`，因为`synchronized`是JVM的内置属性，它能执行一些优化，例如：

对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步。

### 读写锁
`ReentrantLock`是一种标准的互斥锁：每次最多只有一个线程能持有`ReentrantLock`。互斥是一种保守的加锁策略。
```java
  public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
  }
```

在读取锁和写入锁之间的交互可以采用多种实现方式，包括

- 释放优先
  当一个写入操作释放写入输时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程，写线程，还是最先发出请求的线程？
  
- 读线程插队
  如果线程是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问题。
  
- 重入性
  读取锁和写入锁是否是可重入的？
  
- 降级
  如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读取锁？
  
- 升级
  如果一个线程持有读取锁，那么它能否在不释放该锁的情况下获得写入锁？

`ReentrantReadWriteLock`在公平的锁中，等待时间最长的线程将优先获得锁。如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。

在非公平锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程则是不可以的

## 构建自定义的同步工具
### 状态依赖性的管理
