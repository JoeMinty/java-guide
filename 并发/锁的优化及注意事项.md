### 有助于提高锁性能的几点建议
**减少锁持有时间**

减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力

**减小锁粒度**

减小锁粒度，就是指缩小锁定对象的范围，从而降低锁冲突的可能性，进而提高系统的并发能力

**用读写锁来替换独占锁**

在读多写少的场景使用读写锁可以提高系统的并发能力

**锁分离**

`LinkedBlockingQueue`基于链表，用锁分离可以分别作用于队列的前端和尾端。

**重要属性**

```java
    /** Lock held by take, poll, etc */
    private final ReentrantLock takeLock = new ReentrantLock();

    /** Wait queue for waiting takes */
    private final Condition notEmpty = takeLock.newCondition();

    /** Lock held by put, offer, etc */
    private final ReentrantLock putLock = new ReentrantLock();

    /** Wait queue for waiting puts */
    private final Condition notFull = putLock.newCondition();

```

**锁粗化**

虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次性请求，从而减少对锁的请求同步的次数，这个操作叫做锁的粗化


### JVM对锁的优化
**锁偏向**

如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无需再做任何同步操作。

jvm参数`-XX:UseBiasedLocking`可以开启偏向锁

**轻量级锁**

将对象头部作为指针指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。

**自旋锁**



**锁消除**

逃逸分析就是观察某个变量是否会逃出某一个作用域。逃逸分析必须在`-server`模式下进行，可以使用`-XX:+DoEscapeAnalysis`打开逃逸分析，使用`-XX:+EliminateLocks`参数可以打开锁消除






