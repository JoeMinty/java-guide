# 基础构建模块

## 同步容器类
同步器类包括`Vector`和`Hashtable`

同步的封装器类 `Collections.synchronizedXxx`等工厂方法创建的

这些类实现线程安全的方式：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态

### 同步器类的问题
复合操作：迭代（反复访问元素，知道遍历完容器中所有元素，直到遍历完容器中所有元素），跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算

当多个线程同时进行交替操作的时候会造成异常

### 迭代器与ConcurrentModificationException
无论在直接迭代还是`for-each`循环语法中，对容器类进行迭代的标准方式都是使用 `Iterator`。

`fail-fast`意味着当容器在迭代过程中被修改时，会抛出`ConcurrentModificationException`异常，它不是一种完备的处理机制，只能作为并发问题的预警指示器

### 隐藏迭代器
容器的`hashCode`和`equals`等方法也会间接的执行迭代操作，当容器作为另一个容器的元素或者键值时，就会出现这样的情况。同样的，`containsAll`，`removeAll`和`retainAll`等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这种间接的迭代操作都可能抛出`ConcurrentModificationException`。

## 并发容器
`Queue`接口上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。

`BlockingQueue`增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。

### ConcurrentHashMap
参考源码分析`ConcurrentHashMap`篇

### CopyOnWriteArrayList
仅当迭代操作远远多于修改操作时，才应该使用”写入时复制“容器

## 阻塞队列和生产者-消费者模式
一种最常见的生产者-消费者设计模式就是线程池和工作队列的组合，在`Executor`任务执行框架中就体现了这种模式

### 双端队列与工作密取
`Deque`和`BlockingDeque`实现了队列头和队列尾的高效插入和移除。
