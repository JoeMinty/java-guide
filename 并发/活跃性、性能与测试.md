## 避免活跃性危险
### 死锁
#### 锁顺序死锁
如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁的问题。

```
A --> 锁住left  --> 锁住right --> 永久等待
B --> 锁住right --> 锁住left  --> 永久等待
```

#### 动态的锁顺序死锁
```java
  public void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException {
    synchronized (fromAccount) {
      synchronized (toAccount) {
        if (fromAccount.getBalance().compareTo(amount) < 0) {
          throw new InsufficientFundsException();
        } else {
          fromAccount.debit(amount);
          toAccount.debit(amount);
        }
      }  
    }
  }
```
出现死锁的情况
```
A : transferMoney(a, b, 10);
B : transferMoney(b, a, 20);
```

#### 在协作对象之间发生的死锁
如果在持有锁时调用某个外部方法，那么将出现锁活跃性问题。在这个外部方法中可能会获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁

#### 开放调用
如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用（Open Call）

#### 资源死锁
资源池通常采用信号量来实现，当资源池为空时阻塞。

线程饥饿死锁也是资源死锁的一种。一个任务提交另一个任务，并等待被提交任务在单线程的`Executor`中执行完成。

### 死锁的避免与诊断
在使用细粒度锁的程序中，可以通过使用一种两阶段策略（Two-Part Strategy）来检查代码中的死锁：首先，找出在什么地方将获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保他们在整个

#### 支持定时的锁
检测死锁和从死锁中恢复过来，显示的使用`Lock`类中的定时`tryLock`功能来代替内置锁机制。

#### 通过线程转储信息来分析死锁
线程转储（Thread Dump）包括各个运行中的线程的栈追踪信息，还包含了加锁信息。

### 其他活跃性危险
#### 饥饿（Starvation）
引起饥饿的最常见资源就是CPU时钟周期。

要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线程优先级。

#### 活锁（Livelock）
活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。

### 性能与可伸缩性
多线程与单线程相比，总会引入一些额外的性能开销。造成这些开销的操作包含：

- 线程之间的协调（例如加锁，触发信号以及内存同步等）
- 增加的上下文切换
- 线程的创建和销毁
- 线程的调度


