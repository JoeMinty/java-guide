## 线程安全性
在线程安全性的定义中，最核心的概念就是正确性。何为正确性？就是某个类的行为与其规范完全一致。
在良好的规范中通常会定义各种 **不变性条件（Invariant）** 来约束对象的状态，以及定义各种 **后验条件（Postcondition）** 来描述对象操作的结果。

所以，当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。（线程安全类中封装了必要的同步机制）。

**无状态对象一定是线程安全的**

#### 竞态条件
解释：在并发中，由于不恰当的执行顺序而出现不正确的结果。
当某个计算的正确性取决于多个线程的交替执行顺序时，就会发生竞态条件。
最常见的竞态条件类型就是：先检查后执行（check-then-act），就是通过一个可能失效的观测结果来决定下一步的动作。

#### 内置锁
同步代码块
```java
  synchronized(lock) {
    // 访问或修改由锁保护的共享状态
  }
```

内置锁相当于互斥锁，意味着最多只有一个线程能持有这种锁。

#### 重入
内置锁可重入。“重入”意味着获取锁的操作的粒度是线程，而不是“调用”。

## 对象的共享
编写正确的并发程序，关键问题：在访问共享的可变状态时需要进行正确的管理。

#### 可见性

**重排序**
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。

**失效数据**
读写的不同步，导致多个线程获取相同的变量时会出现数据的不同步。

**非原子的64位操作**
非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。所以如果对该变量的读写操作在不同的线程中执行，很可能会读取到某个值的高32位和另一个值的低32位。所以需要用关键字volatile来声明，或者用锁来保护。

**加锁与可见性**
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程必须在同一个锁上同步。

**volatile变量**
volatile修饰的变量，确保更新的操作通知到其他线程。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
volatile变量是一种比synchronized关键字更轻量级的同步机制，但是在可见性上，synchronized更胜一筹。

仅当volatile变量能简化代码的实现以及对同步策略验证时，才应该使用。
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下条件时，才应该使用volatile变量：
1.对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值
2.该变量不会与其他状态变量一起纳入不变性条件中
3.在访问变量时不需要加锁

