## 线程安全性
在线程安全性的定义中，最核心的概念就是正确性。何为正确性？就是某个类的行为与其规范完全一致。
在良好的规范中通常会定义各种 **不变性条件（Invariant）** 来约束对象的状态，以及定义各种 **后验条件（Postcondition）** 来描述对象操作的结果。

所以，当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。（线程安全类中封装了必要的同步机制）。

**无状态对象一定是线程安全的**

### 竞态条件
解释：在并发中，由于不恰当的执行顺序而出现不正确的结果。
当某个计算的正确性取决于多个线程的交替执行顺序时，就会发生竞态条件。
最常见的竞态条件类型就是：先检查后执行（check-then-act），就是通过一个可能失效的观测结果来决定下一步的动作。

### 内置锁
同步代码块
```java
  synchronized(lock) {
    // 访问或修改由锁保护的共享状态
  }
```

内置锁相当于互斥锁，意味着最多只有一个线程能持有这种锁。

### 重入

内置锁可重入。“重入”意味着获取锁的操作的粒度是线程，而不是“调用”。

## 对象的共享

编写正确的并发程序，关键问题：在访问共享的可变状态时需要进行正确的管理。

### 可见性

**重排序**

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。

**失效数据**

读写的不同步，导致多个线程获取相同的变量时会出现数据的不同步。

**非原子的64位操作**

非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。所以如果对该变量的读写操作在不同的线程中执行，很可能会读取到某个值的高32位和另一个值的低32位。所以需要用关键字volatile来声明，或者用锁来保护。

**加锁与可见性**

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程必须在同一个锁上同步。

**volatile变量**

volatile修饰的变量，确保更新的操作通知到其他线程。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
volatile变量是一种比synchronized关键字更轻量级的同步机制，但是在可见性上，synchronized更胜一筹。

仅当volatile变量能简化代码的实现以及对同步策略验证时，才应该使用。
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下条件时，才应该使用volatile变量：
- 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值
- 该变量不会与其他状态变量一起纳入不变性条件中
- 在访问变量时不需要加锁

### 发布与逸出
发布：是对象能够在当前作用域之外的代码中使用
逸出：当某个不应该发布的对象被发布

**安全的对象构造过程**

在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。

### 线程封闭
**Ad-hoc线程封闭**

维护线程封闭性的职责完全由程序实现来承担。但Ad-hoc线程封闭极其脆弱的，所以一般不建议用。

**栈封闭**

栈封闭是线程封闭的一种特例，只能通过局部变量才能访问对象。栈封闭也被称为线程内部使用或者线程局部使用

**ThreadLocal类**

`ThreadLocal`对象通常用于防止对可变的单实例（Singleton）或全局变量进行共享

### 不变性
不可变对象一定是线程安全的。不可变对象只有一种状态，并且该状态由构造函数来控制。
当满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型（事实上并不需要）
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）

**Final域**
final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。

### 安全发布
要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全的发布
- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile类型的域或者AtomicReference对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中

总结：

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
- 线程封闭
- 只读共享
- 线程安全共享
- 保护对象

### 对象的组合
在设计线程安全类的过程中，需要包含以下三个基本要素：
- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

同步策略（synchronization policy）定义了如何在不违背对象**不变条件**或**后验条件**的情况下对其状态的访问操作进行协同。
如果在某个操作中包含有基于状态的先驱条件，那么这个操作就称为依赖状态的操作。

**实例封闭**

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。实例封闭是构建线程安全类的一个最简单的方式，它还使得在锁策略的选择上拥有了更多的灵活性。

### 线程安全性的委托
可以将线程安全性委托给多个状态变量，只要这些变量彼此独立，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全的发布这个变量

### 在现有的线程安全类中添加功能
**客户端加锁机制**

```java
  @ThreadSafe
  public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    
    // ...
    
    public boolean putIfAbsent(E x) {
      synchronized (list) {
        boolean absent = !list.contains(x);
        if (absent) {
          list.add(x); 
        }
        
        return absent;
      }
    }
  }
```

通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。但是，**客户端加锁**却更加脆弱，因为会将与加锁类相关的代码放到其他类中。
**客户端加锁机制**和**扩展类加锁机制**都是将派生类的行为与基类的实现耦合在一起。

**组合**是一种更好的方式。


## 基础构建模块
委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。

### 同步容器类
同步的封装类是由`Collections.synchronizedXxx`等工厂方法创建的，这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

**迭代器与ConcurrentModificationException**

迭代器过程中出现异常，采用的是 **"fail-fast"** 处理机制，

在迭代期间可以通过对容器加锁避免**ConcurrentModificationException**，但是性能差，可能会产生死锁，另一种替代方法就是"克隆"容器，在副本上进行迭代（副本是被封闭在线程中的）

**隐藏迭代器**

封装对象的状态有助于维持不变性条件，封装对象的同步机制同样有助于确保实施同步策略

### 并发容器
同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。但是这会严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。

通过 **并发容器** 来代替 **同步容器** ，可以极大的提高伸缩性并降低风险

两个容器类型（接口）：**Queue** 和 **BlockingQueue**

`Queue`用来临时保存一组等待处理的元素，提供了几种实现：**ConcurrentLinkedQueue**，**PriorityQueue**，`Queue`上的操作不会阻塞

`BlockingQueue`扩展了`Queue`，增加了阻塞的插入和获取等操作。生产者-消费者设计模式经常使用阻塞队列。

**ConcurrentHashMap简介**

技术：分段锁（Lock Striping）-jdk7， CAS-jdk8
并发容器提供的迭代器不会抛出`ConcurrentModificationException`，因此不需要在迭代过程中加锁。 

`ConcurrentHashMap`返回的迭代器具有弱一致性。而并非及时失败。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造后将修改操作反映给容器。


**额外的原子Map操作**

可参考`ConcurrentMap`接口

### CopyOnWriteArrayList && CopyOnWriteArraySet
替代同步的List和Set

“写入时复制（Copy-On-Write）”，在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。每次修改容器时都需要复制底层数组，必然会带来开销，所以仅当迭代操作远远多于修改操作时，才会使用“写入时复制”容器。

**事件通知系统**（深入研究--todo）

### 阻塞队列和生产者-消费者模式
在构建高可用的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

**双端队列与工作密取**

`Deque`是一个双端队列，实现了在队列头和队列尾的高效插入和删除。

**工作密取（Work Stealing）**，每个消费者都有各自的双端队列，如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密的获取工作。

### 阻塞方法和中断方法

**中断**是一种协作机制。

### 同步工具类
同步工具类都包含一些特定的结构化属性：他们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。

**闭锁**

可以延迟线程的进度直到其到达终止状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。例如：

- 确保某个计算在其需要的所有资源都被初始化后才继续执行。（二元闭锁，包括两个状态）
- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动
- 等待直到某个操作的所有参与者都就绪在继续执行

`CountDownLatch`是一种灵活的闭锁实现，可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个整数，标识需要等待的事件数量。`countDown`方法递减计数器，表示一个时间已经发生，而`await`方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么`await`会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。

**FutureTast**

表示一种抽象的可生成结果的计算，`FutureTask`表示的计算结果是通过`Callable`来实现的，相当于一种可生成结果的`Runnable`，并且可以处于以下三种状态：

- 等待运行（Waiting to run）
- 正在运行（Running）
- 运行完成（Completed）

`Future.get`的行为取决于任务的状态。

**信号量**

计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

`Semaphore`中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。

**栅栏**

类似于闭锁，能阻塞一组线程直到某个事件发生。所有线程必须同时到达栅栏位置，才能继续执行。


## 基础总结
- 可变状态时至关重要的

  所有的并发问题都可以归为如何协调对并发状态的访问。可变状态越少，越容易确保线程安全性
  
- 尽量将域申明为final类型，除非需要它们是可变的
- 不可变对象一定是线程安全的
- 封装有助于管理复杂性
- 用锁来保护每个可变变量
- 当保护同一个不变性条件中的所有变量时，要使用同一个锁
- 在执行复合操作期间，要持有锁
- 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题
- 不要故作聪明地推断出不需要使用同步
- 在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的
- 将同步策略文档化

参考：
《Java并发编程实战》--第一部分，基础知识
