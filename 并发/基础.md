## 线程安全性
在线程安全性的定义中，最核心的概念就是正确性。何为正确性？就是某个类的行为与其规范完全一致。
在良好的规范中通常会定义各种 **不变性条件（Invariant）** 来约束对象的状态，以及定义各种 **后验条件（Postcondition）** 来描述对象操作的结果。

所以，当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。（线程安全类中封装了必要的同步机制）。

**无状态对象一定是线程安全的**

### 竞态条件
解释：在并发中，由于不恰当的执行顺序而出现不正确的结果。
当某个计算的正确性取决于多个线程的交替执行顺序时，就会发生竞态条件。
最常见的竞态条件类型就是：先检查后执行（check-then-act），就是通过一个可能失效的观测结果来决定下一步的动作。

### 内置锁
同步代码块
```java
  synchronized(lock) {
    // 访问或修改由锁保护的共享状态
  }
```

内置锁相当于互斥锁，意味着最多只有一个线程能持有这种锁。

### 重入

内置锁可重入。“重入”意味着获取锁的操作的粒度是线程，而不是“调用”。

## 对象的共享

编写正确的并发程序，关键问题：在访问共享的可变状态时需要进行正确的管理。

### 可见性

**重排序**

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。

**失效数据**

读写的不同步，导致多个线程获取相同的变量时会出现数据的不同步。

**非原子的64位操作**

非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。所以如果对该变量的读写操作在不同的线程中执行，很可能会读取到某个值的高32位和另一个值的低32位。所以需要用关键字volatile来声明，或者用锁来保护。

**加锁与可见性**

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程必须在同一个锁上同步。

**volatile变量**

volatile修饰的变量，确保更新的操作通知到其他线程。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
volatile变量是一种比synchronized关键字更轻量级的同步机制，但是在可见性上，synchronized更胜一筹。

仅当volatile变量能简化代码的实现以及对同步策略验证时，才应该使用。
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下条件时，才应该使用volatile变量：
- 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值
- 该变量不会与其他状态变量一起纳入不变性条件中
- 在访问变量时不需要加锁

### 发布与逸出
发布：是对象能够在当前作用域之外的代码中使用
逸出：当某个不应该发布的对象被发布

**安全的对象构造过程**

在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。

### 线程封闭
**Ad-hoc线程封闭**

维护线程封闭性的职责完全由程序实现来承担。但Ad-hoc线程封闭极其脆弱的，所以一般不建议用。

**栈封闭**

栈封闭是线程封闭的一种特例，只能通过局部变量才能访问对象。栈封闭也被称为线程内部使用或者线程局部使用

**ThreadLocal类**

`ThreadLocal`对象通常用于防止对可变的单实例（Singleton）或全局变量进行共享

### 不变性
不可变对象一定是线程安全的。不可变对象只有一种状态，并且该状态由构造函数来控制。
当满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型（事实上并不需要）
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）

**Final域**
final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。

### 安全发布
要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全的发布
- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile类型的域或者AtomicReference对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中

总结：

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
- 线程封闭
- 只读共享
- 线程安全共享
- 保护对象

### 对象的组合
在设计线程安全类的过程中，需要包含以下三个基本要素：
- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

同步策略（synchronization policy）定义了如何在不违背对象**不变条件**或**后验条件**的情况下对其状态的访问操作进行协同。
如果在某个操作中包含有基于状态的先驱条件，那么这个操作就称为依赖状态的操作。

**实例封闭**

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。实例封闭是构建线程安全类的一个最简单的方式，它还使得在锁策略的选择上拥有了更多的灵活性。

### 线程安全性的委托
可以将线程安全性委托给多个状态变量，只要这些变量彼此独立，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全的发布这个变量

### 在现有的线程安全类中添加功能
**客户端加锁机制**

```java
  @ThreadSafe
  public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    
    // ...
    
    public boolean putIfAbsent(E x) {
      synchronized (list) {
        boolean absent = !list.contains(x);
        if (absent) {
          list.add(x); 
        }
        
        return absent;
      }
    }
  }
```

通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。但是，**客户端加锁**却更加脆弱，因为会将与加锁类相关的代码放到其他类中。
**客户端加锁机制**和**扩展类加锁机制**都是将派生类的行为与基类的实现耦合在一起。

**组合**是一种更好的方式。


## 基础构建模块
委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。

### 同步容器类
同步的封装类是由`Collections.synchronizedXxx`等工厂方法创建的，这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

**迭代器与ConcurrentModificationException**

迭代器过程中出现异常，采用的是 **"fail-fast"** 处理机制，

在迭代期间可以通过对容器加锁避免**ConcurrentModificationException**，但是性能差，可能会产生死锁，另一种替代方法就是"克隆"容器，在副本上进行迭代（副本是被封闭在线程中的）

**隐藏迭代器**
封装对象的状态有助于维持不变性条件，封装对象的同步机制同样有助于确保实施同步策略

### 并发容器
同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。但是这会严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。

通过 **并发容器** 来代替 **同步容器** ，可以极大的提高伸缩性并降低风险

两个容器类型（接口）：**Queue** 和 **BlockingQueue**

`Queue`用来临时保存一组等待处理的元素，提供了几种实现：**ConcurrentLinkedQueue**，**PriorityQueue**，`Queue`上的操作不会阻塞

`BlockingQueue`扩展了`Queue`，增加了阻塞的插入和获取等操作。生产者-消费者设计模式经常使用阻塞队列。
