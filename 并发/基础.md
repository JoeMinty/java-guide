## 线程安全性
在线程安全性的定义中，最核心的概念就是正确性。何为正确性？就是某个类的行为与其规范完全一致。
在良好的规范中通常会定义各种 **不变性条件（Invariant）** 来约束对象的状态，以及定义各种 **后验条件（Postcondition）** 来描述对象操作的结果。

所以，当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。（线程安全类中封装了必要的同步机制）。

**无状态对象一定是线程安全的**

### 竞态条件
解释：在并发中，由于不恰当的执行顺序而出现不正确的结果。
当某个计算的正确性取决于多个线程的交替执行顺序时，就会发生竞态条件。
最常见的竞态条件类型就是：先检查后执行（check-then-act），就是通过一个可能失效的观测结果来决定下一步的动作。

### 内置锁
同步代码块
```java
  synchronized(lock) {
    // 访问或修改由锁保护的共享状态
  }
```

内置锁相当于互斥锁，意味着最多只有一个线程能持有这种锁。

### 重入

内置锁可重入。“重入”意味着获取锁的操作的粒度是线程，而不是“调用”。

## 对象的共享

编写正确的并发程序，关键问题：在访问共享的可变状态时需要进行正确的管理。

### 可见性

**重排序**

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。

**失效数据**

读写的不同步，导致多个线程获取相同的变量时会出现数据的不同步。

**非原子的64位操作**

非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。所以如果对该变量的读写操作在不同的线程中执行，很可能会读取到某个值的高32位和另一个值的低32位。所以需要用关键字volatile来声明，或者用锁来保护。

**加锁与可见性**

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程必须在同一个锁上同步。

**volatile变量**

volatile修饰的变量，确保更新的操作通知到其他线程。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
volatile变量是一种比synchronized关键字更轻量级的同步机制，但是在可见性上，synchronized更胜一筹。

仅当volatile变量能简化代码的实现以及对同步策略验证时，才应该使用。
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下条件时，才应该使用volatile变量：
- 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值
- 该变量不会与其他状态变量一起纳入不变性条件中
- 在访问变量时不需要加锁

### 发布与逸出
发布：是对象能够在当前作用域之外的代码中使用
逸出：当某个不应该发布的对象被发布

**安全的对象构造过程**

在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。

### 线程封闭
**Ad-hoc线程封闭**

维护线程封闭性的职责完全由程序实现来承担。但Ad-hoc线程封闭极其脆弱的，所以一般不建议用。

**栈封闭**

栈封闭是线程封闭的一种特例，只能通过局部变量才能访问对象。栈封闭也被称为线程内部使用或者线程局部使用

**ThreadLocal类**

`ThreadLocal`对象通常用于防止对可变的单实例（Singleton）或全局变量进行共享

### 不变性
不可变对象一定是线程安全的。不可变对象只有一种状态，并且该状态由构造函数来控制。
当满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型（事实上并不需要）
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）
