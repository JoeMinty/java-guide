### equals() 和 == && hashCode() 和 equals()

[链接1] (https://www.cnblogs.com/skywang12345/p/3324958.html)

### final
final 关键字是修饰符，主要用于修饰类，方法，变量
+ 当修饰类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
+ 当修饰方法时，防止继承类修改。
+ 当修饰变量时，一旦初始化之后就不能再做修改。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

### static
static 关键字主要有以下使用场景：
+ 修饰成员变量和成员方法: 被static声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
+ 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
+ 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
+ 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

### this && super
+ 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
+ this、super不能用在static方法中。

```
被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；
所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。
```

### String, StringBuffer和StringBuilder
+ **可变性**

`String`类是用`final`关键字字符数组保存的字符串，所以`String`对象是不可变的
`private final char value[]`

`StringBuffer`和`StringBuilder`统一继承`AbstractStringBuilder`,它们也是使用字符数组，只不过没有用`final`关键字修饰，因此它们是可变的
`char value[]`

+ **线程安全**

`String`是不可变的，是常量，线程安全

`StringBuffer`对方法加了同步锁，或在调用的时候加了同步锁，所以线程安全

`StringBuilder`线程不安全

+ **性能**

`String`类型进行改变，每次都会生成一个新的`String`对象，然后将指针指向新的对象

`StringBuffer`每次都对自己进行操作，不会生成新的对象和对象引用

`StringBuilder`比`StringBuffer`性能稍好，但是不安全

#### 总结

操作少量数据用`String`

单线程操作大量数据`StringBuilder`

多线程操作大量数据`StringBuffer`

### JDK,JRE和JVM
- JDK用于开发，JRE用于运行java程序

- JDK和JRE中都包含JVM

- JVM是java编程语言的核心并且具有平台独立性

### 字节码
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器---->机器可执行的二进制机器码---->程序运行

### 接口和抽象类
- 接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法
- 接口中的实例变量默认是final类型的，而抽象类中则不一定
- 一个类可以实现多个接口，但最多只能实现一个抽象类
- 一个类实现接口的话要实现接口的所有方法，而抽象类不一定

### 异常
**Throwable**是所有异常的超类
